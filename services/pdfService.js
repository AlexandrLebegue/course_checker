const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

class PDFService {
    constructor() {
        // Simple PDF service without canvas dependency
    }

    async generateAnalysisReport(resultsData, metadata = {}) {
        return new Promise((resolve, reject) => {
            try {
                // PDF Generation starting
                
                const doc = new PDFDocument({
                    size: 'A4',
                    margins: { top: 50, bottom: 50, left: 50, right: 50 }
                });

                const chunks = [];
                doc.on('data', chunk => chunks.push(chunk));
                doc.on('end', () => resolve(Buffer.concat(chunks)));
                doc.on('error', reject);

                this.generateReport(doc, resultsData, metadata);
                doc.end();
            } catch (error) {
                console.error('PDF Generation Error:', error);
                reject(error);
            }
        });
    }

    async generateReport(doc, resultsData, metadata) {
        // Generate cover page
        await this.generateCoverPage(doc, resultsData, metadata);
        
        // Generate executive summary
        await this.generateExecutiveSummary(doc, resultsData);
        
        // Generate individual results
        await this.generateIndividualResults(doc, resultsData);
        
        // Generate appendices
        await this.generateAppendices(doc, resultsData, metadata);
    }

    async generateCoverPage(doc, resultsData, metadata) {
        // Header with branding
        doc.fontSize(28)
           .fillColor('#2c3e50')
           .text('Course Checker', 50, 80, { align: 'center' });
        
        doc.fontSize(16)
           .fillColor('#7f8c8d')
           .text('AI-Powered Exam Analysis Platform', 50, 120, { align: 'center' });

        // Main title
        doc.fontSize(24)
           .fillColor('#34495e')
           .text('Exam Analysis Report', 50, 180, { align: 'center' });

        // Report details box
        const boxY = 240;
        doc.rect(100, boxY, 400, 200)
           .stroke('#bdc3c7');

        doc.fontSize(14)
           .fillColor('#2c3e50')
           .text('Report Details', 120, boxY + 20);

        const details = [
            `Generated: ${new Date().toLocaleString()}`,
            `Files Analyzed: ${resultsData.results?.length || 0}`,
            `Statement Used: ${metadata.statementUsed ? 'Yes' : 'No'}`,
            `Analysis Type: ${metadata.statementUsed ? 'Enhanced' : 'Basic'}`
        ];

        details.forEach((detail, index) => {
            doc.fontSize(12)
               .fillColor('#34495e')
               .text(detail, 140, boxY + 50 + (index * 25));
        });

        // Footer
        doc.fontSize(10)
           .fillColor('#95a5a6')
           .text('Generated by Course Checker - Powered by AI for Educational Excellence', 50, 750, { align: 'center' });

        doc.addPage();
    }

    async generateExecutiveSummary(doc, resultsData) {
        doc.fontSize(20)
           .fillColor('#2c3e50')
           .text('Executive Summary', 50, 50);

        const results = resultsData.results || [];
        // Processing executive summary
        
        if (results.length === 0) {
            doc.fontSize(12)
               .text('No analysis results available.', 50, 100);
            doc.addPage();
            return;
        }

        // Calculate statistics
        const scores = results.map(result => {
            const analysis = result.analysis?.analysis || result.analysis || {};
            return analysis.overall_score || analysis.score || 0;
        });
        
        // Scores calculated for analysis

        const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
        const maxScore = Math.max(...scores);
        const minScore = Math.min(...scores);

        // Statistics section
        doc.fontSize(14)
           .fillColor('#34495e')
           .text('Overall Statistics', 50, 100);

        const stats = [
            `Average Score: ${avgScore.toFixed(1)}%`,
            `Highest Score: ${maxScore}%`,
            `Lowest Score: ${minScore}%`,
            `Total Files: ${results.length}`
        ];

        stats.forEach((stat, index) => {
            doc.fontSize(12)
               .text(`• ${stat}`, 70, 130 + (index * 20));
        });

        // Generate score distribution chart (text-based)
        doc.fontSize(14)
           .fillColor('#34495e')
           .text('Score Distribution', 50, 250);
        
        this.generateScoreDistributionText(doc, scores, 280);

        // Add correct vs incorrect questions chart
        doc.fontSize(14)
           .fillColor('#34495e')
           .text('Question Performance Analysis', 50, 450);
        
        this.generateQuestionPerformanceChart(doc, results, 480);

        // Key findings
        doc.fontSize(14)
           .fillColor('#34495e')
           .text('Key Findings', 50, 620);

        const findings = this.generateKeyFindings(results);
        findings.forEach((finding, index) => {
            doc.fontSize(12)
               .fillColor('#2c3e50')
               .text(`• ${finding}`, 70, 650 + (index * 20));
        });

        doc.addPage();
    }

    async generateIndividualResults(doc, resultsData) {
        const results = resultsData.results || [];
        
        results.forEach((result, index) => {
            if (index > 0) doc.addPage();
            
            doc.fontSize(18)
               .fillColor('#2c3e50')
               .text(`Student Analysis ${index + 1}`, 50, 50);

            // File info
            doc.fontSize(14)
               .fillColor('#34495e')
               .text('File Information', 50, 90);

            doc.fontSize(12)
               .fillColor('#2c3e50')
               .text(`Filename: ${result.filename}`, 70, 120);

            // Score section
            const analysis = result.analysis?.analysis || result.analysis || {};
            const score = analysis.overall_score || analysis.score || 0;
            const scoreColor = this.getScoreColor(score);

            doc.fontSize(16)
               .fillColor(scoreColor)
               .text(`Score: ${score}%`, 70, 150);

            let yPosition = 190;

            // Enhanced analysis with questions
            if (analysis.question_analysis && analysis.question_analysis.length > 0) {
                doc.fontSize(14)
                   .fillColor('#34495e')
                   .text('Question-by-Question Analysis', 50, yPosition);
                
                yPosition += 40;

                analysis.question_analysis.forEach((question, qIndex) => {
                    if (yPosition > 700) {
                        doc.addPage();
                        yPosition = 50;
                    }

                    const questionColor = question.is_correct ? '#27ae60' : '#e74c3c';
                    
                    doc.fontSize(12)
                       .fillColor('#2c3e50')
                       .text(`Question ${question.question_number}:`, 70, yPosition);
                    
                    doc.fontSize(10)
                       .fillColor(questionColor)
                       .text(`Score: ${question.score || 0}%`, 400, yPosition);

                    yPosition += 20;

                    if (question.statement_question) {
                        doc.fontSize(10)
                           .fillColor('#34495e')
                           .text(`Question: ${question.statement_question}`, 90, yPosition, { width: 400 });
                        yPosition += 25;
                    }

                    if (question.expected_answer) {
                        doc.fontSize(10)
                           .fillColor('#27ae60')
                           .text(`Expected Answer: ${question.expected_answer}`, 90, yPosition, { width: 400 });
                        yPosition += 20;
                    }

                    if (question.student_answer) {
                        doc.fontSize(10)
                           .fillColor('#e74c3c')
                           .text(`Student Answer: ${question.student_answer}`, 90, yPosition, { width: 400 });
                        yPosition += 20;
                    }

                    // Add detailed analysis
                    if (question.analysis || question.explanation) {
                        doc.fontSize(10)
                           .fillColor('#7f8c8d')
                           .text(`Analysis: ${question.analysis || question.explanation}`, 90, yPosition, { width: 400 });
                        yPosition += 25;
                    }

                    if (question.feedback) {
                        doc.fontSize(10)
                           .fillColor('#34495e')
                           .text(`Feedback: ${question.feedback}`, 90, yPosition, { width: 400 });
                        yPosition += 25;
                    }

                    // Add difficulty level if available
                    if (question.difficulty) {
                        doc.fontSize(9)
                           .fillColor('#95a5a6')
                           .text(`Difficulty: ${question.difficulty}`, 90, yPosition);
                        yPosition += 15;
                    }

                    // Add topic/subject if available
                    if (question.topic || question.subject) {
                        doc.fontSize(9)
                           .fillColor('#95a5a6')
                           .text(`Topic: ${question.topic || question.subject}`, 90, yPosition);
                        yPosition += 15;
                    }

                    yPosition += 10;
                });
            } else {
                // Basic analysis - Enhanced error display
                if (analysis.errors && analysis.errors.length > 0) {
                    doc.fontSize(14)
                       .fillColor('#34495e')
                       .text('Identified Errors', 50, yPosition);
                    
                    yPosition += 30;

                    analysis.errors.forEach((error, index) => {
                        if (yPosition > 680) {
                            doc.addPage();
                            yPosition = 50;
                        }

                        // Error number and location
                        doc.fontSize(12)
                           .fillColor('#e74c3c')
                           .text(`Error ${index + 1}: ${error.location || 'Unknown Location'}`, 70, yPosition);
                        yPosition += 20;

                        // Error description
                        doc.fontSize(10)
                           .fillColor('#2c3e50')
                           .text(`Issue: ${error.error || 'Not specified'}`, 90, yPosition, { width: 430 });
                        yPosition += 15;

                        // Detailed explanation
                        if (error.explanation && error.explanation !== error.error) {
                            doc.fontSize(10)
                               .fillColor('#7f8c8d')
                               .text(`Explanation: ${error.explanation}`, 90, yPosition, { width: 430 });
                            yPosition += 20;
                        }

                        yPosition += 10; // Extra spacing between errors
                    });
                }

                if (analysis.corrections && analysis.corrections.length > 0) {
                    yPosition += 20;
                    doc.fontSize(14)
                       .fillColor('#34495e')
                       .text('Detailed Corrections', 50, yPosition);
                    
                    yPosition += 30;

                    analysis.corrections.forEach((correction, index) => {
                        if (yPosition > 680) {
                            doc.addPage();
                            yPosition = 50;
                        }

                        // Correction number and question
                        doc.fontSize(12)
                           .fillColor('#27ae60')
                           .text(`Correction ${index + 1}: ${correction.question || 'Question'}`, 70, yPosition);
                        yPosition += 20;

                        // Expected answer
                        doc.fontSize(10)
                           .fillColor('#27ae60')
                           .text(`✓ Expected Answer:`, 90, yPosition);
                        yPosition += 15;
                        doc.fontSize(9)
                           .fillColor('#2c3e50')
                           .text(`${correction.correct_answer || 'N/A'}`, 110, yPosition, { width: 410 });
                        yPosition += 20;

                        // Student answer
                        doc.fontSize(10)
                           .fillColor('#e74c3c')
                           .text(`✗ Student Answer:`, 90, yPosition);
                        yPosition += 15;
                        doc.fontSize(9)
                           .fillColor('#2c3e50')
                           .text(`${correction.student_answer || 'N/A'}`, 110, yPosition, { width: 410 });
                        yPosition += 25;
                    });
                }
            }

            // Summary
            if (analysis.summary) {
                if (yPosition > 650) {
                    doc.addPage();
                    yPosition = 50;
                }

                yPosition += 20;
                doc.fontSize(14)
                   .fillColor('#34495e')
                   .text('Summary', 50, yPosition);
                
                yPosition += 30;

                let summaryText = typeof analysis.summary === 'string' ? analysis.summary : 'Analysis completed successfully.';
                if (summaryText.startsWith('{') || summaryText.startsWith('[')) {
                    try {
                        const parsed = JSON.parse(summaryText);
                        summaryText = parsed.summary || parsed.message || 'Analysis completed successfully.';
                    } catch (e) {
                        summaryText = summaryText.replace(/[{}"\[\]]/g, '').substring(0, 300) + '...';
                    }
                }

                doc.fontSize(10)
                   .fillColor('#2c3e50')
                   .text(summaryText, 70, yPosition, { width: 450 });
            }
        });
    }

    async generateAppendices(doc, resultsData, metadata) {
        doc.addPage();
        
        doc.fontSize(20)
           .fillColor('#2c3e50')
           .text('Appendices', 50, 50);

        // Analysis methodology
        doc.fontSize(14)
           .fillColor('#34495e')
           .text('Analysis Methodology', 50, 100);

        const methodology = [
            'This report was generated using AI-powered analysis through Google\'s Gemini models.',
            'Files were processed for content extraction and intelligent correction.',
            metadata.statementUsed ? 
                'Enhanced analysis was performed using the provided statement document for question-by-question evaluation.' :
                'Basic analysis was performed without a statement document reference.',
            'Scores are calculated based on correctness, completeness, and methodology.',
            'Recommendations are generated to help improve student performance.'
        ];

        methodology.forEach((text, index) => {
            doc.fontSize(10)
               .fillColor('#2c3e50')
               .text(`• ${text}`, 70, 130 + (index * 25), { width: 450 });
        });

        // Statement information
        if (metadata.statementUsed) {
            doc.fontSize(14)
               .fillColor('#34495e')
               .text('Statement Document Information', 50, 280);

            doc.fontSize(10)
               .fillColor('#2c3e50')
               .text('• Enhanced analysis was enabled using the uploaded statement document', 70, 310)
               .text('• Questions were extracted and used for detailed comparison', 70, 330)
               .text('• Individual question scoring and feedback were provided', 70, 350);
        }

        // Recommendations
        doc.fontSize(14)
           .fillColor('#34495e')
           .text('General Recommendations', 50, 400);

        const recommendations = this.generateRecommendations(resultsData);
        recommendations.forEach((rec, index) => {
            doc.fontSize(10)
               .fillColor('#2c3e50')
               .text(`• ${rec}`, 70, 430 + (index * 20), { width: 450 });
        });
    }

    generateScoreDistributionText(doc, scores, yPosition) {
        const ranges = ['0-20%', '21-40%', '41-60%', '61-80%', '81-100%'];
        const counts = [0, 0, 0, 0, 0];
        const colors = ['#e74c3c', '#f39c12', '#f1c40f', '#2ecc71', '#27ae60'];

        scores.forEach(score => {
            if (score <= 20) counts[0]++;
            else if (score <= 40) counts[1]++;
            else if (score <= 60) counts[2]++;
            else if (score <= 80) counts[3]++;
            else counts[4]++;
        });

        const maxCount = Math.max(...counts);
        const barWidth = 300;

        ranges.forEach((range, index) => {
            const count = counts[index];
            const barLength = maxCount > 0 ? (count / maxCount) * barWidth : 0;
            
            // Draw range label
            doc.fontSize(10)
               .fillColor('#2c3e50')
               .text(`${range}:`, 70, yPosition + (index * 30));
            
            // Draw bar representation with rectangles
            if (barLength > 0) {
                doc.rect(140, yPosition + (index * 30) - 2, barLength, 12)
                   .fillColor(colors[index])
                   .fill();
            }
            
            // Draw count
            doc.fontSize(10)
               .fillColor('#2c3e50')
               .text(`${count} student${count !== 1 ? 's' : ''}`, 450, yPosition + (index * 30));
        });
    }

    generateQuestionPerformanceChart(doc, results, yPosition) {
        // Calculate overall performance statistics from errors and corrections
        let totalErrors = 0;
        let totalCorrections = 0;
        let errorsByLocation = {};

        results.forEach(result => {
            const analysis = result.analysis?.analysis || result.analysis || {};
            // Processing analysis structure
            
            if (analysis.errors && analysis.errors.length > 0) {
                totalErrors += analysis.errors.length;
                analysis.errors.forEach(error => {
                    const location = error.location || 'Unknown';
                    if (!errorsByLocation[location]) {
                        errorsByLocation[location] = { errors: 0, corrections: 0 };
                    }
                    errorsByLocation[location].errors++;
                });
            }
            
            if (analysis.corrections && analysis.corrections.length > 0) {
                totalCorrections += analysis.corrections.length;
                analysis.corrections.forEach(correction => {
                    const location = correction.question || 'Unknown';
                    if (!errorsByLocation[location]) {
                        errorsByLocation[location] = { errors: 0, corrections: 0 };
                    }
                    errorsByLocation[location].corrections++;
                });
            }
        });

        // Analysis complete

        if (totalErrors === 0 && totalCorrections === 0) {
            doc.fontSize(12)
               .fillColor('#7f8c8d')
               .text('No detailed analysis available', 70, yPosition);
            return;
        }

        // Draw overall performance chart
        const chartWidth = 400;
        const totalItems = totalErrors + totalCorrections;
        const errorPercentage = totalItems > 0 ? (totalErrors / totalItems) * 100 : 0;
        const correctionPercentage = totalItems > 0 ? (totalCorrections / totalItems) * 100 : 0;

        // Errors bar (red)
        const errorWidth = totalItems > 0 ? (totalErrors / totalItems) * chartWidth : 0;
        if (errorWidth > 0) {
            doc.rect(70, yPosition, errorWidth, 25)
               .fillColor('#e74c3c')
               .fill();
        }

        // Corrections bar (green)
        const correctionWidth = totalItems > 0 ? (totalCorrections / totalItems) * chartWidth : 0;
        if (correctionWidth > 0) {
            doc.rect(70 + errorWidth, yPosition, correctionWidth, 25)
               .fillColor('#27ae60')
               .fill();
        }

        // Labels
        doc.fontSize(12)
           .fillColor('#e74c3c')
           .text(`Errors: ${totalErrors} (${errorPercentage.toFixed(1)}%)`, 70, yPosition + 35);

        doc.fontSize(12)
           .fillColor('#27ae60')
           .text(`Corrections: ${totalCorrections} (${correctionPercentage.toFixed(1)}%)`, 250, yPosition + 35);

        // Location-by-location breakdown
        doc.fontSize(12)
           .fillColor('#34495e')
           .text('Error Analysis by Location:', 70, yPosition + 65);

        let detailY = yPosition + 90;
        Object.keys(errorsByLocation).forEach((location, index) => {
            if (detailY > 700) {
                doc.addPage();
                detailY = 50;
            }

            const detail = errorsByLocation[location];
            const totalForLocation = detail.errors + detail.corrections;
            
            doc.fontSize(10)
               .fillColor('#2c3e50')
               .text(`${location}:`, 90, detailY, { width: 200 });

            // Mini bar for this location
            if (totalForLocation > 0) {
                const miniBarWidth = 150;
                const errorMiniWidth = (detail.errors / totalForLocation) * miniBarWidth;
                const correctionMiniWidth = (detail.corrections / totalForLocation) * miniBarWidth;

                if (errorMiniWidth > 0) {
                    doc.rect(300, detailY - 2, errorMiniWidth, 10)
                       .fillColor('#e74c3c')
                       .fill();
                }

                if (correctionMiniWidth > 0) {
                    doc.rect(300 + errorMiniWidth, detailY - 2, correctionMiniWidth, 10)
                       .fillColor('#27ae60')
                       .fill();
                }
            }

            doc.fontSize(9)
               .fillColor('#2c3e50')
               .text(`${detail.errors}E/${detail.corrections}C`, 460, detailY);

            detailY += 20;
        });
    }

    getScoreColor(score) {
        if (score >= 90) return '#27ae60';
        if (score >= 75) return '#2ecc71';
        if (score >= 60) return '#f39c12';
        return '#e74c3c';
    }

    generateKeyFindings(results) {
        const findings = [];
        const scores = results.map(r => {
            const analysis = r.analysis?.analysis || r.analysis || {};
            return analysis.overall_score || analysis.score || 0;
        });

        const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
        
        if (avgScore >= 80) {
            findings.push('Overall performance is excellent with strong understanding demonstrated');
        } else if (avgScore >= 60) {
            findings.push('Performance shows good understanding with room for improvement');
        } else {
            findings.push('Performance indicates need for additional support and review');
        }

        const lowScores = scores.filter(s => s < 60).length;
        if (lowScores > 0) {
            findings.push(`${lowScores} student(s) may need additional support`);
        }

        const highScores = scores.filter(s => s >= 90).length;
        if (highScores > 0) {
            findings.push(`${highScores} student(s) demonstrated excellent mastery`);
        }

        return findings;
    }

    generateRecommendations(resultsData) {
        const recommendations = [
            'Review common error patterns identified across multiple students',
            'Provide additional practice for concepts with lower scores',
            'Consider one-on-one support for students with scores below 60%',
            'Celebrate and acknowledge students with excellent performance',
            'Use this analysis to inform future lesson planning and assessment design'
        ];

        return recommendations;
    }
}

module.exports = new PDFService();